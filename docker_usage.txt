
# Como usar:

# Construir a imagem
./docker_valgrind.sh build

# Entrar no container
./docker_valgrind.sh run

# Dentro do container:
./help.sh          # Ver comandos √∫teis
./quick_test.sh    # Teste r√°pido
valgrind ./minishell  # Valgrind manual

# # 4. Limpar imagens
# ./docker_valgrind.sh clean

# ./docker_valgrind.sh build
# ./docker_valgrind.sh run
# ./docker_valgrind.sh test
# ./docker_valgrind.sh clean
# ./docker container prune -f #apenas containers parados (mais seguro)

üîß Dentro do container, voc√™ ter√°:
./help.sh - Mostra comandos √∫teis
./quick_test.sh - Teste r√°pido com Valgrind

valgrind ./minishell - Valgrind manual
./minishell - Executar diretamente

make - Recompilar se necess√°rio

ÔøΩÔøΩ Exemplos de comandos Valgrind:
# Valgrind b√°sico
valgrind ./minishell

# B√°sico
valgrind ./minishell

# Completo
valgrind --leak-check=full --show-leak-kinds=all ./minishell

# Com rastreamento de origem
valgrind --leak-check=full --track-origins=yes ./minishell

# Com log para arquivo
valgrind --leak-check=full --log-file=relatorio.log ./minishell

valgrind --leak-check=full --show-leak-kinds=all --log-file=echo_test.log ./minishell
**MUDAR O NOME DO RELATORIO LOG
# Com mais detalhes
valgrind --leak-check=full --num-callers=20 ./minishell

# Valgrind com teste de comandos
echo "echo hello\npwd\nexit" | valgrind --leak-check=full ./minishell

**Copiar log do docker pro seu rep:
** executar fora do container, no host **
docker cp bbcde0d4fd26:/app/echo_test.log ./echo_test_fixed.log
docker cp bbcde0d4fd26:/app/leak_analysis.log ./leak_analysis.log


root@bbcde0d4fd26:/app# echo $HOSTNAME
bbcde0d4fd26


üìä Resumo das Flags
        Flag	                O que faz	                Quando usar
--leak-check=full	        An√°lise completa de leaks	    Sempre
--show-leak-kinds=all	    Mostra todos os tipos	        Sempre
--track-origins=yes	        Rastreia origem de valores	    Debug avan√ßado
--show-reachable=yes	    Detalha still reachable	        An√°lise profunda
--num-callers=20	        Mais fun√ß√µes na stack	        C√≥digo complexo
--log-file=arquivo.log	    Salva em arquivo	            An√°lise posterior


üê≥ Explica√ß√£o do Dockerfile
O que faz: Define a imagem base (Ubuntu 22.04 LTS)
Por que: Ubuntu √© est√°vel, tem todas as depend√™ncias necess√°rias para C e Valgrind
Alternativas: ubuntu:latest, debian:bullseye, alpine:latest


# Ver o log completo
cat meu_teste.log

# Ver apenas o resumo
grep -E "(definitely lost|indirectly lost|possibly lost|still reachable)" meu_teste.log

# Ver apenas vazamentos definitivos
grep "definitely lost" meu_teste.log

# Ver quantas linhas tem o log
wc -l meu_teste.log

# Ver as primeiras 20 linhas
head -20 meu_teste.log

# Ver as √∫ltimas 20 linhas
tail -20 meu_teste.log

Curta e direta: sim ‚Äî no Minishell, o √∫nico ‚Äústill reachable‚Äù aceit√°vel √© o que vem da GNU Readline (e libhistory). 
O subject explicita que readline() pode causar leaks e voc√™ n√£o √© obrigada a corrigi-los; j√° todo 
o resto de mem√≥ria alocada no heap deve ser liberada, ou vira flag de Leaks na defesa.

*** As diferen√ßas entre os tipos de leaks do Valgrind s√£o: **
*"Definitely lost" (Definitivamente perdido):
Mem√≥ria alocada que n√£o pode mais ser acessada por nenhum ponteiro
Representa um vazamento real que precisa ser corrigido
Exemplo: malloc(10) sem guardar o ponteiro ou liberar com free()

*"Indirectly lost" (Indiretamente perdido):
Mem√≥ria que s√≥ poderia ser acessada atrav√©s de blocos que j√° foram "definitely lost"
Ocorre em estruturas de dados encadeadas (√°rvores, listas)
Exemplo: Se perder o ponteiro para o n√≥ raiz de uma √°rvore, todos os n√≥s filhos ficam "indirectly lost"

*"Still reachable" (Ainda alcan√ß√°vel):
Mem√≥ria alocada que n√£o foi liberada, mas ainda tem ponteiros v√°lidos apontando para ela
N√£o √© um vazamento cr√≠tico, pois o sistema operacional recupera essa mem√≥ria ao encerrar o programa
Comum em programas que alocam mem√≥ria que dura at√© o fim da execu√ß√£o
Ok: ‚Äústill reachable‚Äù cuja callstack mostra readline, _rl_*, libreadline, libhistory. Mostra no Valgrind e cita o subject.
N√£o ok: qualquer ‚Äústill reachable‚Äù, ‚Äúdefinitely lost‚Äù ou ‚Äúindirectly lost‚Äù que passe por fun√ß√µes/arquivos  do projeto.
 A corre√ß√£o cobra heap limpo do teu c√≥digo.